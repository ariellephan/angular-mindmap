/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('fs'), require('@angular/core'), require('@angular/compiler'), require('@angular/platform-server'), require('@nguniversal/express-engine/tokens')) :
	typeof define === 'function' && define.amd ? define('@nguniversal/express-engine', ['exports', 'fs', '@angular/core', '@angular/compiler', '@angular/platform-server', '@nguniversal/express-engine/tokens'], factory) :
	(factory((global.nguniversal = global.nguniversal || {}, global.nguniversal.expressEngine = {}),global.fs,global.ng.core,global.ng.compiler,global.ng.platformServer,global.nguniversal.expressEngine.tokens));
}(this, (function (exports,fs,core,compiler,platformServer,tokens) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FileLoader = /** @class */ (function () {
    function FileLoader() {
    }
    /**
     * @param {?} url
     * @return {?}
     */
    FileLoader.prototype.get = /**
     * @param {?} url
     * @return {?}
     */
    function (url) {
        return new Promise(function (resolve, reject) {
            fs.readFile(url, function (err, buffer) {
                if (err) {
                    return reject(err);
                }
                resolve(buffer.toString());
            });
        });
    };
    return FileLoader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This holds a cached version of each index used.
 */
var /** @type {?} */ templateCache = {};
/**
 * Map of Module Factories
 */
var /** @type {?} */ factoryCacheMap = new Map();
/**
 * This is an express engine for handling Angular Applications
 * @param {?} setupOptions
 * @return {?}
 */
function ngExpressEngine(setupOptions) {
    var /** @type {?} */ compilerFactory = platformServer.platformDynamicServer().injector.get(core.CompilerFactory);
    var /** @type {?} */ compiler$$1 = compilerFactory.createCompiler([
        {
            providers: [
                { provide: compiler.ResourceLoader, useClass: FileLoader, deps: [] }
            ]
        }
    ]);
    return function (filePath, options, callback) {
        options.providers = options.providers || [];
        try {
            var /** @type {?} */ moduleOrFactory = options.bootstrap || setupOptions.bootstrap;
            if (!moduleOrFactory) {
                throw new Error('You must pass in a NgModule or NgModuleFactory to be bootstrapped');
            }
            setupOptions.providers = setupOptions.providers || [];
            var /** @type {?} */ extraProviders_1 = setupOptions.providers.concat(options.providers, getReqResProviders(options.req, options.res), [
                {
                    provide: platformServer.INITIAL_CONFIG,
                    useValue: {
                        document: options.document || getDocument(filePath),
                        url: options.url || options.req.originalUrl
                    }
                }
            ]);
            getFactory(moduleOrFactory, compiler$$1)
                .then(function (factory) {
                return platformServer.renderModuleFactory(factory, {
                    extraProviders: extraProviders_1
                });
            })
                .then(function (html) {
                callback(null, html);
            }, function (err) {
                callback(err);
            });
        }
        catch (/** @type {?} */ err) {
            callback(err);
        }
    };
}
/**
 * Get a factory from a bootstrapped module/ module factory
 * @param {?} moduleOrFactory
 * @param {?} compiler
 * @return {?}
 */
function getFactory(moduleOrFactory, compiler$$1) {
    return new Promise(function (resolve, reject) {
        // If module has been compiled AoT
        if (moduleOrFactory instanceof core.NgModuleFactory) {
            resolve(moduleOrFactory);
            return;
        }
        else {
            var /** @type {?} */ moduleFactory = factoryCacheMap.get(moduleOrFactory);
            // If module factory is cached
            if (moduleFactory) {
                resolve(moduleFactory);
                return;
            }
            // Compile the module and cache it
            compiler$$1.compileModuleAsync(moduleOrFactory)
                .then(function (factory) {
                factoryCacheMap.set(moduleOrFactory, factory);
                resolve(factory);
            }, (function (err) {
                reject(err);
            }));
        }
    });
}
/**
 * Get providers of the request and response
 * @param {?} req
 * @param {?=} res
 * @return {?}
 */
function getReqResProviders(req, res) {
    var /** @type {?} */ providers = [
        {
            provide: tokens.REQUEST,
            useValue: req
        }
    ];
    if (res) {
        providers.push({
            provide: tokens.RESPONSE,
            useValue: res
        });
    }
    return providers;
}
/**
 * Get the document at the file path
 * @param {?} filePath
 * @return {?}
 */
function getDocument(filePath) {
    return templateCache[filePath] = templateCache[filePath] || fs.readFileSync(filePath).toString();
}

exports.ngExpressEngine = ngExpressEngine;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=express-engine.umd.js.map
